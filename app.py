import os
import json
import tkinter as tk
import customtkinter as ck
from customtkinter import CTk, CTkButton, CTkEntry, CTkTextbox, CTkScrollbar, CTkSwitch
import pickle

ck.set_appearance_mode("dark")


# Class: GUI to interact with the index generated by the mined paths from the UAMS Exchange Server
#   - Updated regulary by a set task assigned on the main OS pushing VBA Script
class FolderIndexApp(CTk):

    def __init__(self):
        super().__init__()
        dev = True

        # THE BUILD (EXE) HAS ALL FILES ACCESSED VIA THE "_internal" directory
        if dev:
            # dev path for assets
            self.iconbitmap("images/file.ico")
        else:
            # build path to assets
            self.iconbitmap("_internal/images/file.ico")

        self.search_mode = ck.BooleanVar(value=True)
        self.search_public_folders = ck.BooleanVar(value=True)
        self.search_global_contacts = ck.BooleanVar(value=True)
        self.title("TSC: Public Folders Index")
        self.configure(bg="#000000")
        self.window_width = 850
        self.window_height = 700
        self.geometry(f"{self.window_width}x{self.window_height}")
        self.minsize(width=self.window_width, height=self.window_height)
        self.paths_found = []
        self.username = self.get_username()  # used to get a dynamic path to the pkl index
        self.path_to_data = f"path\\to\\PublicFolderIndex.pkl"
        self.path_to_contact_data = f"path\\to\\GlobalContactsIndex.pkl"
        self.global_index_not_found = False
        self.public_index_not_found = False

        # Load the index with error handling
        try:
            self.public_index = self.load_folder_index(self.path_to_data)
        except FileNotFoundError:
            self.public_index = None
            print(f"Error: The index file 'path\\to\\PublicFolderIndex.pkl")

        try:
            self.global_index = self.load_folder_index(self.path_to_contact_data)
        except FileNotFoundError:
            self.global_index = None
            print(f"Error: The index file 'path\\to\\GlobalContactsIndex.pkl")

        self.font = ck.CTkFont(family="Roboto", size=14, weight="bold")
        self.toggle_font = ck.CTkFont(family="Roboto", size=18, weight="bold")
        self.title_font = ck.CTkFont(family="Roboto", size=20, weight="bold")

        # Configure grid layout
        self.grid_rowconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=3)
        self.grid_rowconfigure(2, weight=1)
        self.grid_rowconfigure(3, weight=10)
        self.grid_columnconfigure(0, weight=1)

        # Create a frame for the search input field and submit button
        self.title_frame = ck.CTkFrame(self, fg_color="#141414")
        self.title_frame.grid(row=0, column=0, padx=20, pady=10, sticky="nsew")

        self.title = ck.CTkLabel(self.title_frame, text="TSC: Public Folder Index", fg_color="#141414",
                                 text_color="silver", font=self.title_font
                                 )
        self.title.pack(pady=10, fill="y", expand=True)

        # Create a frame for the search input field and submit button
        self.input_frame = ck.CTkFrame(self, fg_color="#141414")
        self.input_frame.grid(row=1, column=0, padx=20, pady=10, sticky="nsew")

        # Create button title
        self.button_title = ck.CTkLabel(
            self.input_frame, text="Search Index:", fg_color="#141414", text_color="silver", font=self.font, height=40
        )
        self.button_title.pack(side="left", padx=10, pady=10)

        # Create the search input field
        self.search_input = CTkEntry(
            self.input_frame, fg_color="#141414", text_color="silver", font=self.font, width=500, height=40
        )
        self.search_input.pack(side="left", padx=10, pady=10, fill="x", expand=True)

        # Create the submit button
        self.submit_button = CTkButton(
            self.input_frame, text="Submit", fg_color="#141414", text_color="silver", font=self.font,
            command=lambda: self.search_idx_for_path(self.search_input.get().strip()),
        )
        self.submit_button.pack(side="left", padx=10, pady=8, fill="y")

        # Create a frame for the toggle switch
        self.toggle_frame = ck.CTkFrame(self, fg_color="#141414")
        self.toggle_frame.grid(row=2, column=0, padx=20, pady=5, sticky="nsew")

        # Create a sub-frame for centering the widgets
        self.center_frame = ck.CTkFrame(self.toggle_frame, fg_color="#141414")
        self.center_frame.pack(expand=True, fill="x")  # Center frame expands to fill toggle_frame

        # Create the toggle switch
        self.search_mode_switch = CTkSwitch(
            self.center_frame, text="Substring Search Enabled", fg_color="#141414", text_color="silver",
            font=self.toggle_font, command=self.toggle_search_mode, switch_width=35, variable=self.search_mode
        )
        self.search_mode_switch.pack(pady=(20, 10), fill="y", expand=True)

        self.search_public_folders_switch = CTkSwitch(
            self.center_frame, text="Public Folders Enabled", fg_color="#141414", text_color="silver",
            font=self.toggle_font, command=self.toggle_public_folders, switch_width=35,
            variable=self.search_public_folders
        )
        self.search_public_folders_switch.pack(pady=10, fill="y", expand=True)

        self.search_global_contacts_switch = CTkSwitch(
            self.center_frame, text="Global Contacts Enabled", fg_color="#141414", text_color="silver",
            font=self.toggle_font, command=self.toggle_global_contacts, switch_width=35,
            variable=self.search_global_contacts
        )
        self.search_global_contacts_switch.pack(pady=(10, 20), fill="y", expand=True)

        # Create a frame for the results text box
        self.results_frame = ck.CTkFrame(self, fg_color="#141414")
        self.results_frame.grid(row=3, column=0, padx=20, pady=10, sticky="nsew")

        # Create a scrolling text box for displaying results
        self.results_text = CTkTextbox(
            self.results_frame, fg_color="#141414", text_color="silver", font=self.font, wrap="word",
            activate_scrollbars=False
        )
        self.results_text.pack(padx=(10, 0), pady=10, side="left", fill="both", expand=True)

        self.scrollbar = CTkScrollbar(self.results_frame, command=self.results_text.yview)
        self.scrollbar.pack(side="right", fill="y", padx=(0, 10), pady=10)
        self.results_text.configure(yscrollcommand=self.scrollbar.set)

        self.submit_button.bind("<Enter>", self.on_enter)
        self.submit_button.bind("<ButtonRelease-1>", self.on_enter)
        self.submit_button.bind("<Leave>", self.on_leave)

        self.scrollbar.bind("<Enter>", self.on_enter_scrollbar)

        self.search_input.bind("<Return>", lambda event: self.search_idx_for_path(self.search_input.get().strip()))

        self.write_error_messages([
            "Welcome to the TSC: Public Folders Index!",
            "INFO:",
            "- Use the substring toggle to switch from exact matches to searches containing the phrase and back.",
            "- Searches are not case sensitive.",
            "- Highlight any path(s) and press 'Ctrl + c' to copy the path out (right-click will not pull a menu up).",
            "- This application requires internet access and the Box Desktop Application (signed in and synced).",
            "- Ensure you have at least Editor rights to this Software Box Folder."
        ])

    # Methods
    def get_username(self):
        # Attempt to read username from JSON file
        try:
            with open('username.json', 'r') as f:
                data = json.load(f)
                username = data.get('username', '')
                if username:
                    return username
        except FileNotFoundError:
            pass  # Intentionally left empty, this is logic I have left in, in that case I decide to allow user's
            # manual override.

        # If username not found in JSON file, fallback to system username
        return os.environ.get('USERNAME', 'default_username')

    def write_error_messages(self, error_messages):
        self.results_text.configure(state="normal")
        self.results_text.delete("1.0", "end")  # Clear previous results
        for line in error_messages:
            self.results_text.insert(tk.END, line + "\n\n")
        self.results_text.configure(state="disabled")

    def toggle_search_mode(self):
        self.search_mode = not self.search_mode
        if self.search_mode:
            self.search_mode_switch.configure(text="Substring Search Enabled")
        else:
            self.search_mode_switch.configure(text="Substring Search Disabled")
        # print(f"Search mode toggled. Substring search is now {'enabled' if self.search_mode else 'disabled'}.")

    def toggle_public_folders(self):
        self.search_public_folders = not self.search_public_folders
        if self.search_public_folders:
            self.search_public_folders_switch.configure(text="Public Folders Enabled")
        else:
            self.search_public_folders_switch.configure(text="Public Folders Disabled")

    def toggle_global_contacts(self):
        self.search_global_contacts = not self.search_global_contacts
        if self.search_global_contacts:
            self.search_global_contacts_switch.configure(text="Global Contacts Enabled")
        else:
            self.search_global_contacts_switch.configure(text="Global Contacts Disabled")

    def load_folder_index(self, file_path):
        # print(f"file_path: {file_path}")
        abs_path = os.path.abspath(file_path)
        # Debugging: Print the absolute path
        print(f"Absolute path to index file: {abs_path}")
        with open(abs_path, 'rb') as file:
            idx = pickle.load(file)
        return idx

    def search_paths(self, directory_name):
        if self.search_mode:
            # Substring search
            results = []
            for key in self.public_index.keys():
                if directory_name.lower() in key.lower():
                    results.extend(self.public_index[key])
            return results
        else:
            # Case-insensitive match search
            results = []
            for key in self.public_index.keys():
                if directory_name.lower() == key.lower():
                    results.extend(self.public_index[key])
            return results

    def search_contacts(self, contact_name):
        if self.search_mode:
            # Substring search
            results = set()
            for key in self.global_index.keys():
                if contact_name.lower() in key.lower():
                    results.add(self.global_index[key])
            return results
        else:
            # Case-insensitive match search
            results = set()
            for key in self.global_index.keys():
                if contact_name.lower() == key.lower():
                    results.add(self.global_index[key])
            return results

    def search_idx_for_path(self, directory_name):
        if directory_name == "":
            self.write_error_messages([
                "It's looking awfully empty here..."
            ])
        elif not self.search_global_contacts and not self.search_public_folders:
            self.write_error_messages([
                "Toggle Global Contacts or Public Folders on to perform a search.."
            ])
        else:
            if self.search_public_folders:
                self.paths_found = self.search_paths(directory_name)
            if self.search_global_contacts:
                self.contacts_found = self.search_contacts(directory_name)
            self.update_results_text()

    def update_results_text(self):
        line_break = "--------------------------------------------------------------------------------------------------------------"
        self.results_text.configure(state="normal")
        self.results_text.delete("1.0", "end")  # Clear previous results
        if self.search_public_folders:
            self.results_text.insert(tk.END, line_break + "\n")
            self.results_text.insert(tk.END, "Public Folders Results:" + "\n")
            self.results_text.insert(tk.END, line_break + "\n\n")
            if len(self.paths_found) != 0:
                for path in self.paths_found:
                    self.results_text.insert(tk.END, path + "\n\n")
            else:
                self.results_text.insert(tk.END, "No paths found." + "\n")
                self.results_text.insert(tk.END,
                                         "If this path is SUPPOSED to exist, it might have been created recently." + "\n")
                self.results_text.insert(tk.END, "The index is updated every one - two weeks." + "\n")
        if self.search_global_contacts:
            self.results_text.insert(tk.END, "\n" + line_break + "\n")
            self.results_text.insert(tk.END, "Global Contacts Results:" + "\n")
            self.results_text.insert(tk.END, line_break + "\n\n")
            if len(self.contacts_found) != 0:
                for contact in self.contacts_found:
                    self.results_text.insert(tk.END, contact + "\n\n")
            else:
                self.results_text.insert(tk.END, "No contacts found." + "\n")
                self.results_text.insert(tk.END,
                                         "If this contact is SUPPOSED to exist, it might have been created recently." + "\n")
                self.results_text.insert(tk.END, "The index is updated every one - two weeks." + "\n")
        self.results_text.configure(state="disabled")

    # Bind Methods
    def on_enter(self, e):
        self.submit_button.configure(fg_color="silver", text_color="#141414", cursor="hand2")

    def on_leave(self, e):
        self.submit_button.configure(fg_color="#141414", text_color="silver")

    def on_enter_scrollbar(self, e):
        self.scrollbar.configure(cursor="hand2")


# Main - Who knew?
if __name__ == "__main__":
    app = FolderIndexApp()
    app.mainloop()
